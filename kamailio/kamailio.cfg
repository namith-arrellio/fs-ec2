#!KAMAILIO
#
# Kamailio Configuration for FreeSWITCH Integration
# Handles: SIP Registration, Presence/BLF, Routing to FreeSWITCH
#

#!define WITH_MYSQL
#!define WITH_AUTH
#!define WITH_USRLOCDB
#!define WITH_PRESENCE
#!define WITH_NAT

####### Global Parameters #########

### LOG Levels: 3=DBG, 2=INFO, 1=NOTICE, 0=WARN, -1=ERR
debug=2
log_stderror=yes
memdbg=5
memlog=5
log_facility=LOG_LOCAL0
log_prefix="{$mt $hdr(CSeq) $ci} "

# Listen addresses
listen=udp:0.0.0.0:5060
listen=tcp:0.0.0.0:5060

# Advertise public IP (set via environment variable)
#!substdef "!ADVERTISED_IP!ENV_ADVERTISED_IP!g"
advertised_address="ADVERTISED_IP"

# Async workers
children=4
async_workers=4

# Life time of TCP connection when there is no traffic
tcp_connection_lifetime=3605

# Disable DNS lookup
dns=no
rev_dns=no

####### Modules Section ########

loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "textopsx.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "acc.so"
loadmodule "counters.so"

#!ifdef WITH_AUTH
loadmodule "auth.so"
loadmodule "auth_db.so"
#!endif

#!ifdef WITH_MYSQL
loadmodule "db_mysql.so"
#!endif

#!ifdef WITH_PRESENCE
loadmodule "presence.so"
loadmodule "presence_xml.so"
loadmodule "presence_dialoginfo.so"
loadmodule "pua.so"
loadmodule "pua_dialoginfo.so"
#!endif

#!ifdef WITH_NAT
loadmodule "nathelper.so"
loadmodule "rtpengine.so"
#!endif

loadmodule "htable.so"
loadmodule "pike.so"
loadmodule "debugger.so"
loadmodule "dialog.so"
loadmodule "sdpops.so"

# ----- jsonrpcs params -----
modparam("jsonrpcs", "fifo_name", "/var/run/kamailio/kamailio_rpc.fifo")
modparam("jsonrpcs", "dgram_socket", "/var/run/kamailio/kamailio_rpc.sock")

# ----- ctl params -----
modparam("ctl", "binrpc", "unix:/var/run/kamailio/kamailio_ctl")

# ----- tm params -----
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)

# ----- rr params -----
modparam("rr", "enable_full_lr", 0)
modparam("rr", "append_fromtag", 0)

# ----- registrar params -----
modparam("registrar", "method_filtering", 1)
modparam("registrar", "max_expires", 3600)
modparam("registrar", "gruu_enabled", 0)
modparam("registrar", "use_path", 1)
modparam("registrar", "path_mode", 0)

# ----- usrloc params -----
#!ifdef WITH_USRLOCDB
modparam("usrloc", "db_url", "mysql://kamailio:kamailiorw@127.0.0.1/kamailio")
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "use_domain", 1)
#!endif

# ----- auth_db params -----
#!ifdef WITH_AUTH
modparam("auth_db", "db_url", "mysql://kamailio:kamailiorw@127.0.0.1/kamailio")
modparam("auth_db", "calculate_ha1", 1)
modparam("auth_db", "password_column", "password")
modparam("auth_db", "load_credentials", "")
modparam("auth_db", "use_domain", 1)
#!endif

# ----- presence params -----
#!ifdef WITH_PRESENCE
modparam("presence", "db_url", "mysql://kamailio:kamailiorw@127.0.0.1/kamailio")
modparam("presence", "server_address", "sip:ADVERTISED_IP:5060")
modparam("presence", "send_fast_notify", 1)
modparam("presence", "clean_period", 60)
modparam("presence", "db_update_period", 30)
modparam("presence", "subs_db_mode", 1)

modparam("presence_xml", "db_url", "mysql://kamailio:kamailiorw@127.0.0.1/kamailio")
modparam("presence_xml", "force_active", 1)
modparam("presence_xml", "disable_bla", 0)
modparam("presence_xml", "disable_winfo", 0)
modparam("presence_xml", "disable_presence", 0)

modparam("pua", "db_url", "mysql://kamailio:kamailiorw@127.0.0.1/kamailio")
modparam("pua", "db_mode", 2)
modparam("pua", "update_period", 60)

modparam("pua_dialoginfo", "include_callid", 1)
modparam("pua_dialoginfo", "include_localremote", 1)
modparam("pua_dialoginfo", "include_tags", 1)
#!endif

# ----- nathelper params -----
#!ifdef WITH_NAT
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", 7)
modparam("nathelper", "sipping_from", "sip:pinger@kamailio.local")
modparam("nathelper", "received_avp", "$avp(RECEIVED)")
#!endif

# ----- dialog params -----
modparam("dialog", "db_url", "mysql://kamailio:kamailiorw@127.0.0.1/kamailio")
modparam("dialog", "db_mode", 1)
modparam("dialog", "dlg_flag", 4)

# ----- htable params -----
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")

# ----- pike params -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

####### Routing Logic ########

# FreeSWITCH address (internal profile on port 5070)
#!substdef "!FREESWITCH_IP!127.0.0.1!g"
#!substdef "!FREESWITCH_PORT!5070!g"

# Main SIP request routing logic
request_route {
    # Per request initial checks
    route(REQINIT);

    # NAT detection
    route(NATDETECT);

    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RELAY);
        }
        exit;
    }

    # Handle retransmissions
    if (!is_method("ACK")) {
        if(t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    # Handle requests within SIP dialogs
    route(WITHINDLG);

    ### Only initial requests from here ###

    # Authentication
    route(AUTH);

    # Record routing for dialog forming requests
    if (is_method("INVITE|SUBSCRIBE")) {
        record_route();
    }

    # Handle REGISTER
    if (is_method("REGISTER")) {
        route(REGISTRAR);
        exit;
    }

    # Handle PUBLISH
    if (is_method("PUBLISH")) {
        route(PRESENCE_PUBLISH);
        exit;
    }

    # Handle SUBSCRIBE
    if (is_method("SUBSCRIBE")) {
        route(PRESENCE_SUBSCRIBE);
        exit;
    }

    # Dispatch destinations for requests
    route(DISPATCH);
}

# Wrapper for relaying requests
route[RELAY] {
    # Enable additional event routes for forwarded requests
    if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
    }
    if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
    }
    if (is_method("INVITE")) {
        if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
    }

    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

# Per request initial checks
route[REQINIT] {
    # Flood detection
    if(src_ip!=myself) {
        if($sht(ipban=>$si)!=$null) {
            xdbg("Request from blocked IP - $si\n");
            exit;
        }
        if (!pike_check_req()) {
            $sht(ipban=>$si) = 1;
            xlog("L_ALERT", "Pike blocking $si\n");
            exit;
        }
    }

    if($ua =~ "friendly|scanner|sipcli|sipvicious|VaxSIPUserAgent") {
        sl_send_reply("200", "OK");
        exit;
    }

    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483","Too Many Hops");
        exit;
    }

    if(is_method("OPTIONS") && uri==myself && $rU==$null) {
        sl_send_reply("200","Keepalive");
        exit;
    }

    if(!sanity_check("17895", "7")) {
        xlog("Malformed SIP request from $si:$sp\n");
        exit;
    }
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
    if (!has_totag()) return;

    if (loose_route()) {
        if (is_method("BYE")) {
            # Dialog accounting
        } else if (is_method("NOTIFY")) {
            record_route();
        }
        route(RELAY);
        exit;
    }

    if (is_method("ACK")) {
        if (t_check_trans()) {
            route(RELAY);
            exit;
        } else {
            exit;
        }
    }
    sl_send_reply("404","Not here");
    exit;
}

# Authentication route
route[AUTH] {
#!ifdef WITH_AUTH
    if (is_method("REGISTER") || from_uri!=myself) {
        if (!auth_check("$fd", "subscriber", "1")) {
            auth_challenge("$fd", "0");
            exit;
        }
        consume_credentials();
    }
#!endif
    return;
}

# Registration handling
route[REGISTRAR] {
    if (!save("location")) {
        sl_reply_error();
    }
    exit;
}

# Presence SUBSCRIBE handling
route[PRESENCE_SUBSCRIBE] {
#!ifdef WITH_PRESENCE
    if (!t_newtran()) {
        sl_reply_error();
        exit;
    }
    
    xlog("L_INFO", "SUBSCRIBE from $fu to $ru\n");
    
    if(handle_subscribe()) {
        xlog("L_INFO", "SUBSCRIBE handled successfully\n");
    } else {
        xlog("L_ERR", "Failed to handle SUBSCRIBE\n");
    }
    exit;
#!endif
    sl_send_reply("501", "Not Implemented");
    exit;
}

# Presence PUBLISH handling
route[PRESENCE_PUBLISH] {
#!ifdef WITH_PRESENCE
    if (!t_newtran()) {
        sl_reply_error();
        exit;
    }
    
    xlog("L_INFO", "PUBLISH from $fu for $ru\n");
    
    if(handle_publish()) {
        xlog("L_INFO", "PUBLISH handled successfully\n");
    } else {
        xlog("L_ERR", "Failed to handle PUBLISH\n");
    }
    exit;
#!endif
    sl_send_reply("501", "Not Implemented");
    exit;
}

# NAT detection
route[NATDETECT] {
#!ifdef WITH_NAT
    force_rport();
    if (nat_uac_test("19")) {
        if (is_method("REGISTER")) {
            fix_nated_register();
        } else {
            if(is_first_hop()) {
                set_contact_alias();
            }
        }
        setflag(5);
    }
#!endif
    return;
}

# NAT handling for outgoing
route[NATMANAGE] {
#!ifdef WITH_NAT
    if (is_request()) {
        if(has_totag()) {
            if(check_route_param("nat=yes")) {
                setbflag(5);
            }
        }
    }
    if (!(isflagset(5) || isbflagset(5))) return;

    if (is_request()) {
        if (!has_totag()) {
            if(t_is_branch_route()) {
                add_rr_param(";nat=yes");
            }
        }
    }
    if (is_reply()) {
        if(isbflagset(5)) {
            if(is_first_hop()) {
                set_contact_alias();
            }
        }
    }
#!endif
    return;
}

# Dispatch to FreeSWITCH
route[DISPATCH] {
    # Check if call is for a local user
    if (is_method("INVITE")) {
        # Try to find the user locally
        if (lookup("location")) {
            # Track dialog for presence
            dlg_manage();
            route(RELAY);
            exit;
        }
    }

    # Forward to FreeSWITCH for other handling
    $du = "sip:FREESWITCH_IP:FREESWITCH_PORT";
    route(RELAY);
}

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
    xdbg("New branch [$T_branch_idx] to $ru\n");
    route(NATMANAGE);
}

# Manage incoming replies
reply_route {
    if(!sanity_check("17604", "6")) {
        xlog("Malformed SIP reply from $si:$sp\n");
        drop;
    }
}

onreply_route[MANAGE_REPLY] {
    xdbg("Incoming reply\n");
    if(status=~"[12][0-9][0-9]") {
        route(NATMANAGE);
    }
}

# Manage failure routing cases
failure_route[MANAGE_FAILURE] {
    route(NATMANAGE);

    if (t_is_canceled()) exit;
}

# Dialog event route for presence publishing
event_route[dialog:start] {
    xlog("L_INFO", "Dialog started: $dlg(callid)\n");
}

event_route[dialog:end] {
    xlog("L_INFO", "Dialog ended: $dlg(callid)\n");
}

