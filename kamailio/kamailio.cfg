#!KAMAILIO
#
# Kamailio Configuration for FreeSWITCH Integration
# Architecture: Kamailio = SIP Proxy/Registrar + Trunk Gateway
#              FreeSWITCH = Media Server (IVR, Voicemail, Conferencing)
#
# Call Flows:
#   - Phones register to Kamailio
#   - SIP Trunks connect to Kamailio
#   - Kamailio routes to FreeSWITCH for media services
#   - FreeSWITCH routes back to Kamailio for final delivery
#

#!define WITH_MYSQL
#!define WITH_AUTH
#!define WITH_USRLOCDB
#!define WITH_PRESENCE
#!define WITH_NAT
#!define WITH_DISPATCHER

####### Global Parameters #########

### LOG Levels: 3=DBG, 2=INFO, 1=NOTICE, 0=WARN, -1=ERR
debug=2
log_stderror=yes
memdbg=5
memlog=5
log_facility=LOG_LOCAL0
log_prefix="{$mt $hdr(CSeq) $ci} "

# Listen addresses
listen=udp:0.0.0.0:5060
listen=tcp:0.0.0.0:5060

# Advertise public IP (replaced by entrypoint.sh)
advertised_address="ADVERTISED_IP"

# Async workers
children=4
async_workers=4

# Life time of TCP connection when there is no traffic
tcp_connection_lifetime=3605

# Enable DNS for trunk hostname resolution
dns=yes
rev_dns=no
dns_cache_init=on
use_dns_cache=on

####### Modules Section ########

loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "textopsx.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "acc.so"
loadmodule "counters.so"

#!ifdef WITH_AUTH
loadmodule "auth.so"
loadmodule "auth_db.so"
#!endif

#!ifdef WITH_MYSQL
loadmodule "db_mysql.so"
#!endif

#!ifdef WITH_PRESENCE
loadmodule "presence.so"
loadmodule "presence_xml.so"
loadmodule "presence_dialoginfo.so"
loadmodule "pua.so"
loadmodule "pua_dialoginfo.so"
#!endif

#!ifdef WITH_NAT
loadmodule "nathelper.so"
#!endif

#!ifdef WITH_DISPATCHER
loadmodule "dispatcher.so"
#!endif

loadmodule "uac.so"
loadmodule "htable.so"
loadmodule "pike.so"
loadmodule "debugger.so"
loadmodule "dialog.so"
loadmodule "sdpops.so"

# ----- jsonrpcs params -----
modparam("jsonrpcs", "fifo_name", "/var/run/kamailio/kamailio_rpc.fifo")
modparam("jsonrpcs", "dgram_socket", "/var/run/kamailio/kamailio_rpc.sock")

# ----- ctl params -----
modparam("ctl", "binrpc", "unix:/var/run/kamailio/kamailio_ctl")

# ----- tm params -----
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)

# ----- rr params -----
modparam("rr", "enable_full_lr", 0)
modparam("rr", "append_fromtag", 1)

# ----- registrar params -----
modparam("registrar", "method_filtering", 1)
modparam("registrar", "max_expires", 3600)
modparam("registrar", "gruu_enabled", 0)
modparam("registrar", "use_path", 1)
modparam("registrar", "path_mode", 0)

# ----- usrloc params -----
#!ifdef WITH_USRLOCDB
modparam("usrloc", "db_url", "mysql://kamailio:kamailiorw@127.0.0.1/kamailio")
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "use_domain", 1)
modparam("usrloc", "nat_bflag", 6)
#!endif

# ----- auth_db params -----
#!ifdef WITH_AUTH
modparam("auth_db", "db_url", "mysql://kamailio:kamailiorw@127.0.0.1/kamailio")
modparam("auth_db", "calculate_ha1", 1)
modparam("auth_db", "password_column", "password")
modparam("auth_db", "load_credentials", "")
modparam("auth_db", "use_domain", 1)
#!endif

# ----- presence params -----
#!ifdef WITH_PRESENCE
modparam("presence", "db_url", "mysql://kamailio:kamailiorw@127.0.0.1/kamailio")
modparam("presence", "server_address", "sip:ADVERTISED_IP:5060")
modparam("presence", "send_fast_notify", 1)
modparam("presence", "clean_period", 60)
modparam("presence", "db_update_period", 30)
modparam("presence", "subs_db_mode", 1)

modparam("presence_xml", "db_url", "mysql://kamailio:kamailiorw@127.0.0.1/kamailio")
modparam("presence_xml", "force_active", 1)
modparam("presence_xml", "disable_bla", 0)
modparam("presence_xml", "disable_winfo", 0)
modparam("presence_xml", "disable_presence", 0)

modparam("pua", "db_url", "mysql://kamailio:kamailiorw@127.0.0.1/kamailio")
modparam("pua", "db_mode", 2)
modparam("pua", "update_period", 60)

modparam("pua_dialoginfo", "include_callid", 1)
modparam("pua_dialoginfo", "include_localremote", 1)
modparam("pua_dialoginfo", "include_tags", 1)
#!endif

# ----- nathelper params -----
#!ifdef WITH_NAT
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", 7)
modparam("nathelper", "sipping_from", "sip:pinger@kamailio.local")
modparam("nathelper", "received_avp", "$avp(RECEIVED)")
#!endif

# ----- dispatcher params -----
#!ifdef WITH_DISPATCHER
# Dispatcher for SIP trunk load balancing and failover
modparam("dispatcher", "db_url", "mysql://kamailio:kamailiorw@127.0.0.1/kamailio")
modparam("dispatcher", "table_name", "dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "ds_ping_interval", 30)
modparam("dispatcher", "ds_probing_mode", 1)
#!endif

# ----- uac params -----
modparam("uac", "restore_mode", "auto")

# ----- dialog params -----
modparam("dialog", "db_url", "mysql://kamailio:kamailiorw@127.0.0.1/kamailio")
modparam("dialog", "db_mode", 1)
modparam("dialog", "dlg_flag", 4)

# ----- htable params -----
# IP ban table
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")
# DID to store mapping table
modparam("htable", "htable", "did=>size=4;initval=0;")

# ----- pike params -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

####### Routing Logic ########

# FreeSWITCH address (internal profile on port 5070)
#!define FREESWITCH_IP "10.0.0.135"
#!define FREESWITCH_PORT 5070
#!define FREESWITCH_URI "sip:10.0.0.135:5070"

# DID Mappings: DID number -> store domain
# Store 1: 7577828734
# Store 2: 7372449688

# Trunk dispatcher group IDs
# Group 1: Telnyx trunk

# Main SIP request routing logic
request_route {
    # Per request initial checks
    route(REQINIT);

    # NAT detection
    route(NATDETECT);

    # CANCEL processing
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RELAY);
        }
        exit;
    }

    # Handle retransmissions
    if (!is_method("ACK")) {
        if(t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    # Handle requests within SIP dialogs
    route(WITHINDLG);

    ### Only initial requests from here ###

    # Handle REGISTER (phones register to Kamailio)
    if (is_method("REGISTER")) {
        route(AUTH);
        route(REGISTRAR);
        exit;
    }

    # Check if request is from FreeSWITCH (media server)
    if (route(FROMFREESWITCH)) {
        xlog("L_INFO", "Request from FreeSWITCH: $rm $ru\n");
        route(FREESWITCH_ROUTING);
        exit;
    }

    # Check if request is from SIP trunk
    if (route(FROMTRUNK)) {
        xlog("L_INFO", "Inbound from SIP Trunk: $rm $ru (DID: $rU)\n");
        route(TRUNK_INBOUND);
        exit;
    }

    # Authentication for phone requests
    route(AUTH);

    # Record routing for dialog forming requests
    if (is_method("INVITE|SUBSCRIBE")) {
        record_route();
    }

    # Handle PUBLISH
    if (is_method("PUBLISH")) {
        route(PRESENCE_PUBLISH);
        exit;
    }

    # Handle SUBSCRIBE
    if (is_method("SUBSCRIBE")) {
        route(PRESENCE_SUBSCRIBE);
        exit;
    }

    # Route phone calls
    route(PHONE_ROUTING);
}

# Wrapper for relaying requests
route[RELAY] {
    if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
    }
    if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
    }
    if (is_method("INVITE")) {
        if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
    }

    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

# Per request initial checks
route[REQINIT] {
    # Flood detection from external sources
    if(src_ip!=myself) {
        if($sht(ipban=>$si)!=$null) {
            xdbg("Request from blocked IP - $si\n");
            exit;
        }
        if (!pike_check_req()) {
            $sht(ipban=>$si) = 1;
            xlog("L_ALERT", "Pike blocking $si\n");
            exit;
        }
    }

    # Block scanners
    if($ua =~ "friendly|scanner|sipcli|sipvicious|VaxSIPUserAgent") {
        sl_send_reply("200", "OK");
        exit;
    }

    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483","Too Many Hops");
        exit;
    }

    if(is_method("OPTIONS") && uri==myself && $rU==$null) {
        sl_send_reply("200","Keepalive");
        exit;
    }

    if(!sanity_check("17895", "7")) {
        xlog("Malformed SIP request from $si:$sp\n");
        exit;
    }
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
    if (!has_totag()) return;

    if (loose_route()) {
        if (is_method("NOTIFY")) {
            record_route();
        }
        route(RELAY);
        exit;
    }

    if (is_method("ACK")) {
        if (t_check_trans()) {
            route(RELAY);
            exit;
        } else {
            exit;
        }
    }
    sl_send_reply("404","Not here");
    exit;
}

# Authentication route
route[AUTH] {
#!ifdef WITH_AUTH
    if (is_method("REGISTER") || from_uri!=myself) {
        if (!auth_check("$fd", "subscriber", "1")) {
            auth_challenge("$fd", "0");
            exit;
        }
        consume_credentials();
    }
#!endif
    return;
}

# Registration handling
route[REGISTRAR] {
    if (!save("location")) {
        sl_reply_error();
    }
    exit;
}

# Check if request is from FreeSWITCH
route[FROMFREESWITCH] {
    # FreeSWITCH internal profile on port 5070
    if ($si == FREESWITCH_IP && $sp == FREESWITCH_PORT) {
        return 1;
    }
    # Also check localhost
    if ($si == "127.0.0.1" && $sp == FREESWITCH_PORT) {
        return 1;
    }
    return -1;
}

# Check if request is from a SIP trunk
route[FROMTRUNK] {
#!ifdef WITH_DISPATCHER
    # Check if source IP is a known trunk from dispatcher
    if (ds_is_from_list("1")) {
        return 1;
    }
#!endif
    # Telnyx SIP addresses (backup check)
    if ($si =~ "sip.telnyx.com|64.16.17|64.16.18|185.246.") {
        return 1;
    }
    return -1;
}

# Handle calls FROM FreeSWITCH (routing back to phones or trunks)
route[FREESWITCH_ROUTING] {
    if (is_method("INVITE")) {
        dlg_manage();
        
        # Check if this is destined for a trunk (outbound call)
        # FreeSWITCH will set X-Route-To-Trunk header for outbound
        if ($hdr(X-Route-To-Trunk) != $null) {
            xlog("L_INFO", "FreeSWITCH requesting trunk routing to: $rU\n");
            route(TRUNK_OUTBOUND);
            exit;
        }
        
        # Get the store domain from FreeSWITCH header
        $var(store_domain) = $hdr(X-Store-Domain);
        if ($var(store_domain) == $null || $var(store_domain) == "") {
            # Try to get from sip_invite_domain or default to store1.local
            $var(store_domain) = "store1.local";
        }
        
        xlog("L_INFO", "FreeSWITCH routing to user $rU at domain $var(store_domain)\n");
        
        # Rewrite the RURI to use the correct domain for location lookup
        # Users are registered as ext@store1.local, not ext@127.0.0.1
        $ru = "sip:" + $rU + "@" + $var(store_domain);
        
        xlog("L_INFO", "Rewritten RURI: $ru\n");
        
        # Now lookup the registered location
        if (lookup("location")) {
            xlog("L_INFO", "Routing to registered phone: $ru\n");
            
            # Handle NAT - phones behind NAT need special routing
            # The nathelper module stores received IP/port during registration
            # handle_ruri_alias() extracts the real public IP from stored alias
            if (handle_ruri_alias()) {
                xlog("L_INFO", "NAT alias applied, new target: $ru\n");
            } else {
                xlog("L_INFO", "No NAT alias, using contact as-is: $ru\n");
            }
            
            # Add record-route for in-dialog requests
            record_route();
            
            # Apply NAT management for the reply path
            route(NATMANAGE);
            
            route(RELAY);
            exit;
        }
        
        xlog("L_WARN", "User $rU not found at domain $var(store_domain)\n");
        sl_send_reply("404", "User Not Found");
        exit;
    }
    route(RELAY);
    exit;
}

# Handle inbound calls from SIP trunk
route[TRUNK_INBOUND] {
    if (!is_method("INVITE")) {
        route(RELAY);
        exit;
    }

    # Track dialog
    dlg_manage();

    # Get the DID (destination number)
    $var(did) = $rU;
    
    # Normalize DID (remove +1 prefix if present)
    if ($var(did) =~ "^\+1") {
        $var(did) = $(var(did){s.substr,2,0});
    } else if ($var(did) =~ "^1[0-9]{10}$") {
        $var(did) = $(var(did){s.substr,1,0});
    }
    
    xlog("L_INFO", "Inbound DID: $var(did) (original: $rU)\n");
    
    # Store DID info for FreeSWITCH
    # Map DID to store domain
    $var(store_domain) = "";
    
    # Store 1: 7577828734
    if ($var(did) == "7577828734") {
        $var(store_domain) = "store1.local";
    }
    # Store 2: 7372449688
    else if ($var(did) == "7372449688") {
        $var(store_domain) = "store2.local";
    }
    
    if ($var(store_domain) == "") {
        xlog("L_WARN", "Unknown DID: $var(did), rejecting\n");
        sl_send_reply("404", "DID Not Found");
        exit;
    }
    
    xlog("L_INFO", "DID $var(did) -> $var(store_domain), routing to FreeSWITCH\n");
    
    # Add headers for FreeSWITCH to use
    append_hf("X-Store-Domain: $var(store_domain)\r\n");
    append_hf("X-Original-DID: $var(did)\r\n");
    append_hf("X-Inbound-Trunk: true\r\n");
    
    # Route to FreeSWITCH for IVR/processing
    $du = FREESWITCH_URI;
    record_route();
    route(RELAY);
    exit;
}

# Handle outbound calls to SIP trunk
route[TRUNK_OUTBOUND] {
#!ifdef WITH_DISPATCHER
    # Get store domain from header (set by FreeSWITCH)
    $var(store_domain) = $hdr(X-Store-Domain);
    $var(dest_number) = $rU;
    
    xlog("L_INFO", "Outbound trunk call: $var(dest_number) from $var(store_domain)\n");
    
    # Remove internal headers before sending to trunk
    remove_hf("X-Route-To-Trunk");
    remove_hf("X-Store-Domain");
    
    # Set caller ID based on store
    if ($var(store_domain) == "store1.local") {
        # Store 1 caller ID
        $fU = "7577828734";
        uac_replace_from("", "sip:+17577828734@sip.telnyx.com");
    } else if ($var(store_domain) == "store2.local") {
        # Store 2 caller ID
        $fU = "7372449688";
        uac_replace_from("", "sip:+17372449688@sip.telnyx.com");
    }
    
    # Format destination number for trunk (E.164)
    if (!($var(dest_number) =~ "^\+")) {
        if ($var(dest_number) =~ "^1[0-9]{10}$") {
            $rU = "+" + $var(dest_number);
        } else if ($var(dest_number) =~ "^[0-9]{10}$") {
            $rU = "+1" + $var(dest_number);
        }
    }
    
    # Use dispatcher to select trunk
    if (!ds_select_dst("1", "4")) {
        xlog("L_ERR", "No trunk available for outbound call\n");
        sl_send_reply("503", "Service Unavailable");
        exit;
    }
    
    xlog("L_INFO", "Routing to trunk: $du\n");
    
    t_on_failure("TRUNK_FAILURE");
    route(RELAY);
    exit;
#!else
    sl_send_reply("503", "Trunking not configured");
    exit;
#!endif
}

# Handle calls from phones
route[PHONE_ROUTING] {
    if (!is_method("INVITE")) {
        # For non-INVITE, try location lookup or relay
        if (lookup("location")) {
            route(RELAY);
        }
        sl_send_reply("404", "Not Found");
        exit;
    }

    # Track dialog for presence/BLF
    dlg_manage();
    
    $var(dest) = $rU;
    $var(from_domain) = $fd;
    
    xlog("L_INFO", "Phone call from $fu to $var(dest) (domain: $var(from_domain))\n");
    
    # Check if this is an outbound call (10+ digit number)
    if ($var(dest) =~ "^[+]?1?[0-9]{10,}$") {
        xlog("L_INFO", "Outbound call detected: $var(dest)\n");
        # Route to FreeSWITCH for processing, it will route back with X-Route-To-Trunk
        append_hf("X-Store-Domain: $var(from_domain)\r\n");
        append_hf("X-Outbound-Call: true\r\n");
        $du = FREESWITCH_URI;
        # record_route already called in main request_route
        route(RELAY);
        exit;
    }
    
    # Check if this is an internal extension (1000-1019)
    if ($var(dest) =~ "^10[01][0-9]$") {
        xlog("L_INFO", "Internal extension call: $var(dest)\n");
        # Route to FreeSWITCH for call processing (recording, etc.)
        append_hf("X-Store-Domain: $var(from_domain)\r\n");
        append_hf("X-Internal-Call: true\r\n");
        $du = FREESWITCH_URI;
        route(RELAY);
        exit;
    }
    
    # Check if this is a park slot (700-709)
    if ($var(dest) =~ "^70[0-9]$") {
        xlog("L_INFO", "Park slot call: $var(dest)\n");
        append_hf("X-Store-Domain: $var(from_domain)\r\n");
        append_hf("X-Park-Call: true\r\n");
        $du = FREESWITCH_URI;
        route(RELAY);
        exit;
    }
    
    # Check if this is a feature code (*xx)
    if ($var(dest) =~ "^\*[0-9]+$") {
        xlog("L_INFO", "Feature code: $var(dest)\n");
        append_hf("X-Store-Domain: $var(from_domain)\r\n");
        $du = FREESWITCH_URI;
        route(RELAY);
        exit;
    }
    
    # Default: route to FreeSWITCH for dial plan processing
    xlog("L_INFO", "Default routing to FreeSWITCH: $var(dest)\n");
    append_hf("X-Store-Domain: $var(from_domain)\r\n");
    $du = FREESWITCH_URI;
    record_route();
    route(RELAY);
}

# Route calls to a registered location
route[TOLOCATION] {
    if (!lookup("location")) {
        sl_send_reply("404", "Not Found");
        exit;
    }
    route(RELAY);
}

# Presence SUBSCRIBE handling
route[PRESENCE_SUBSCRIBE] {
#!ifdef WITH_PRESENCE
    if (!t_newtran()) {
        sl_reply_error();
        exit;
    }
    
    xlog("L_INFO", "SUBSCRIBE from $fu to $ru\n");
    
    if(handle_subscribe()) {
        xlog("L_INFO", "SUBSCRIBE handled successfully\n");
    } else {
        xlog("L_ERR", "Failed to handle SUBSCRIBE\n");
    }
    exit;
#!endif
    sl_send_reply("501", "Not Implemented");
    exit;
}

# Presence PUBLISH handling
route[PRESENCE_PUBLISH] {
#!ifdef WITH_PRESENCE
    if (!t_newtran()) {
        sl_reply_error();
        exit;
    }
    
    xlog("L_INFO", "PUBLISH from $fu for $ru\n");
    
    if(handle_publish()) {
        xlog("L_INFO", "PUBLISH handled successfully\n");
    } else {
        xlog("L_ERR", "Failed to handle PUBLISH\n");
    }
    exit;
#!endif
    sl_send_reply("501", "Not Implemented");
    exit;
}

# NAT detection
route[NATDETECT] {
#!ifdef WITH_NAT
    force_rport();
    if (nat_uac_test("19")) {
        if (is_method("REGISTER")) {
            fix_nated_register();
            # IMPORTANT: Also set contact alias so handle_ruri_alias() works later
            set_contact_alias();
        } else {
            if(is_first_hop()) {
                set_contact_alias();
            }
        }
        setflag(5);
        setbflag(6);  # Set branch flag for NAT (used by usrloc nat_bflag)
    }
#!endif
    return;
}

# NAT handling for outgoing
route[NATMANAGE] {
#!ifdef WITH_NAT
    if (is_request()) {
        if(has_totag()) {
            if(check_route_param("nat=yes")) {
                setbflag(5);
            }
        }
    }
    if (!(isflagset(5) || isbflagset(5))) return;

    if (is_request()) {
        if (!has_totag()) {
            if(t_is_branch_route()) {
                add_rr_param(";nat=yes");
            }
        }
    }
    if (is_reply()) {
        if(isbflagset(5)) {
            if(is_first_hop()) {
                set_contact_alias();
            }
        }
    }
#!endif
    return;
}

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
    xdbg("New branch [$T_branch_idx] to $ru\n");
    route(NATMANAGE);
}

# Manage incoming replies
reply_route {
    if(!sanity_check("17604", "6")) {
        xlog("Malformed SIP reply from $si:$sp\n");
        drop;
    }
}

onreply_route[MANAGE_REPLY] {
    xdbg("Incoming reply\n");
    if(status=~"[12][0-9][0-9]") {
        route(NATMANAGE);
    }
}

# Manage failure routing cases
failure_route[MANAGE_FAILURE] {
    route(NATMANAGE);

    if (t_is_canceled()) exit;
}

# Trunk failure handling
failure_route[TRUNK_FAILURE] {
    if (t_is_canceled()) exit;
    
    xlog("L_WARN", "Trunk failure, trying next...\n");
    
    # Try next trunk in the dispatcher set
    if (t_check_status("5[0-9][0-9]|6[0-9][0-9]")) {
        if (ds_next_dst()) {
            xlog("L_INFO", "Trying next trunk: $du\n");
            t_on_failure("TRUNK_FAILURE");
            route(RELAY);
            exit;
        }
    }
    
    xlog("L_ERR", "All trunks failed\n");
}

# Dialog event route for presence publishing
event_route[dialog:start] {
    xlog("L_INFO", "Dialog started: $dlg(callid)\n");
}

event_route[dialog:end] {
    xlog("L_INFO", "Dialog ended: $dlg(callid)\n");
}
